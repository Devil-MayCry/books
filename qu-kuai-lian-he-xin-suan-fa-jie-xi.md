## 

## 容错问题和Paxos算法

* 对于一组节点，如果所有节点用一个串行化器作代理，就可以实现状态复制。这也叫做主-从复制
* 两段锁协议（2PL）和两阶段提交协议（2PC）
* 如果节点可以在宕机后恢复，较之一个简单的串行化器，2PL和2PC能提供更好的一致性保证，但对异常处理不好。
* Paxos:  投票算法

## 共识机制

* 共识定义：

* 一致性：所有好节点的决策值必定相同

* 可终止性： 所有好节点在有限的时间内结束决策过程

* 有效性：选择出的决策值必须是某个节点的输入值

* 异步模型中，算法是基于事件的（一旦收到消息......则开始执行.....）

* 异步运行时（Asynchronous runtime）是指最坏情况下（合法输入），从开始执行到运行借宿时所需的时间单位数量

* 如果有节点可能崩溃时，**不存在确定性容错共识算法**

* 配置树的每一个叶节点都是上一个树节点通过一次转换（只涉及配置中一个节点）而来的

* 如果一个系统是在一个二价配置中，这个系统必须在有限的时间内达到一个关键配置，否则这个系统永远不能解决共识问题

* 如果一个配置树包含一个关键配置，单个节点的崩溃会导致一个二价的叶子节点，也就是会阻碍算法达成一致

* C01 == C10   要注意，C01并不是先进行0变换，得到一个配置，再进行1变换，得到最终配置。而是没有中间配置，直接得到的最终配置

* P34页倒数第五行：因此我们....      （不懂,u是任意的么？如果是，为啥任意节点u一定存在一个转换，可以达到0价配置。如果不是任意，那么单节点崩溃不一定会导致二价）

* 随机共识：要么所有节点都从相同的输入值开始，这很容易达成共识。否则，所有节点都抛硬币，直到大部分节点碰巧得到一个相同的值

* 随机共识算法能在最多f&lt;n/2个节点崩溃的情况下在期望O\(2的n次方\)内达成布尔型共识。他的缺点是，期望时间太长，要达成共识需要很长时间

* 共享硬币能够在常数级的可预测的轮数中结束，并且能容忍最多f&lt;n/3个节点崩溃

## 拜占庭协议

* 拜占庭；一个可能呈现任意行为的节点
* 拜占庭协议：在一个存在拜占庭节点的系统中达成的共识叫做拜占庭协议
* 如果一个算法可以在存在f个拜占庭节点的情况下正确工作，则该算法为f-可适用
* 如果网络只包含三个节点，且其中一个为拜占庭节点，则网络不能达成符合全部相同有效性要求的拜占庭协议
* 若一个有n个节点的网络中存在f&gt;=n/3个拜占庭节点，则该网络不能达成拜占庭协议
* 国王算法： 实现了全部相同有效性，解决了拜占庭协议问题。但指定国王的过程本身就是一个拜占庭协定任务
* 在网络中存在不超过 f&lt;n/10个拜占庭节点的情况下，异步模式下的拜占庭协定算法能够得到解决
* 异步模式下，在最坏情况，期望的运行时间将随节点数量n呈指数增长

## 认证的协定

* 如果一个节点不对消息签名，那么好的节点就不会接收该消息
* 认证的拜占庭协定可以容忍f&lt;n拜占庭错误，同时在f+1轮终止
* 命令：如果客户端要更新（或者读取数据），该客户端在一条Request消息中发送一个适当的命令c到主节点p。除命令c自身之外，该Request消息还包括一个时间戳t。客户端对该消息签名来保证其真实性
* 一组互相矛盾的签名的消息可以构成对一些节点的不当行为的证明
* 安全性

* 提交证书: 一个提交证书 S 包含来自 2f +1个不同副本r的2f+1个一致的且已签名的消息

* 视图改变：自发换掉拜占庭主节点，并且要恢复新视图的历史

* Zyzzyva算法

## 仲裁系统

* 仲裁是所有节点的一个子集。一个仲裁系统是多个仲裁构成的集合，且任意两两交集不为空
* 过半数仲裁系统： 每个仲裁具有 n/2取下界 + 1个节点
* 访问策略: 在一个仲裁系统中访问某个仲裁Q的概率 P\(Q\)
* 一个访问策略在某节点的负载：仲裁系统中包含改节点的仲裁的访问概率和
* 一个访问策略在一个仲裁系统的负载为在系统中任意一个节点上最大的负载
* 一个仲裁系统的负载最小的仲裁系统中的访问策略负载

* 仲裁的工作量是该仲裁中所有节点的数量

* 一个访问策略引发的在一个仲裁系统上的工作量是平均（期望）被访问的节点个数

* 一个仲裁系统的工作量是最小的访问策略引发的工作量

* 当每个单一节点出错概率大于1/2时，单节点仲裁系统可能是个好选择

* 仲裁系统的负载必然 &gt;= 1 /  √n

## 最终一致性及比特币

* 一个分布式系统不可能同时实现一致性，可用性以及分区容忍性。可满足其中任意两个要求，但不能同时满足三个
* 最终一致性



