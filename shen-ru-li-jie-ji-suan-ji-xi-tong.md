## 提高系统性能

* 选择合适的算法和数据结构
* 写出的源码要能够被编译器优化成高效可执行代码（所以要先理解编译器的原理和上限）
* 分治任务，并行执行

* 提高系统性能和代码可读性要维持一个平衡

* 减少程序不必要的工作

* 通过变换减少任务之间的耦合，然后并行执行

* 研究汇编是理解优化编译器的最有效途径

### 编译器优化

* 编译器优化能提高运行效率，但会增加代码复杂度，debug更复杂
* 当存在memory aliasing的风险时,会限制编译器的优化
* 当有inline substitution \(++\)也会降低编译器优化
* 循环是容易出现优化机会，比如遍历数组时

                `long length = vec_length(v)`

                `for(i = 0 ;i < length; i++)`

           比

                `for(i = 0 ;i <vec_length(v) ; i++)`

           好

  编译器不知道vec\_length\(v\)有没有副作用，所以不会帮你优化

* 减少函数调用

* 减少不必要的内存寻址（需要对汇编一定了解）

### 处理器原理

* 处理器可以把一些串行的指令，在底层并行化
* ICU:生成命令 EU：执行命令
* branch指令即跳转指令，它可以是taken式的，控制权交到跳转目标。可以是非taken的，控制权继续到指令序列的下一个。
* 现代处理器会有branch预测功能，guess是否是token，甚至跳转目标，提前执行。如果出错，重置然后重新执行\(在EU中\)
* EU分为很多单元（数字计算，存储，加载，branch），分别处理不同的指令。他们在一起才能提供良好的功能。可能有多个相同功能单元，这也为并行处理提供了条件
* ICU中指令被解码后，加入一个队列。有一个retirement unit负责跟踪指令执行。 当一个指令已经执行，或者一个branch预测确认正确后，指令就retired了
* 只有当指令retired后，程序寄存器才会出现update。
* EU单元之间能够直接通信.最常见的通信是register renaming

### 处理器操作模型

* 处理器计算时，数据可以在寄存器之间流动（通过operation），也可以不经过寄存器，比如从内存读取（为一个operation）后，直接给另一个operation
* 寄存器分四类：只读，只写，局部，循环
* 分析数据流模型，找出影响程序性能的关键路径（例如舍弃“判断和跳转”之类的和数据无相关性的操作，以及在同一操作下，latency较大的是关键路径）
* loop rolling能够减少循环次数，是性能更加接近latency bounds，但不能突破，因为还是受关键路径的限制
* 并发处理能突破latency bounds，也就是map-reduce思想，此时，并发的结果限制就是由load unit决定了。结果不能超过thoroughput bound:

  ```
   合适的并发量可以通过如下计算: k = C * L   C是Capacity， L是Latency
  ```

* Reassociation Transformation : 通过调整新读取的变量和上次结果的相加顺序，将data-dependency的关键路径量减少，来提高效率

* 如果一个程序需要总共N个计算操作，处理器有C个功能单元，单元之间的issue time是I ，那么程序至少需要N \* I / C 个单位周期执行

* 寄存器溢出：当并行量超过可用寄存器数量时，编译器会进行溢出，将一些临时变量存储在内存中，也就是在运行栈中开辟空间。这会导致性能损耗，反而不利于性能优化

* 由于分支预测错误带来的回滚操作等问题，会使性能降低。gcc会通过将分支的两边情况都进行计算，在决策时选择一个计算结果，这样降低回滚的性能损失。一般情况，现代处理器的优化很好，预测成功率很好，也不用太担心

* 当测试数据是非常规数据时，会导致预测率降低。当这种不可避免时，我们要通过一些代码技巧来优化：

  条件 -&gt;   计算  —&gt;   value  -&gt;   update state  要好于   条件 ——&gt;   update state

  ```
  根据条件，将值赋予不同结果，然后将结果赋予状态。比根据条件，直接更新状态好（见《深入理解计算机系统》5.11.2）
  ```

### 处理器内存操作性能优化：

* 处理器的功能单元都有各自的缓冲区域，处理内存操作请求（例如加载单元和存储单元）。每个单元**初始化**一个操作都需要1个时钟刻度
* 加载单元的性能取决于pipelining capability 和 latency
* 存储\(写\)单元通常能在一个时钟刻度内完成, 但读写操作直接有依赖会降低性能，如下条
* 存储单元有一个缓冲区，包含了等待要存储的数据和地址，它要等待数据缓存的更新完成。当缓存更新后，缓冲区一起执行写入。此时，当一个加载操作发生时，它要检查存储缓冲区的地址是否有匹配的。如果有，说明缓冲区较新，把它读取出来作为加载
* 性能评测工具: gprof,可以分析各个函数消耗的时间
* gprof 的timing并不精确



