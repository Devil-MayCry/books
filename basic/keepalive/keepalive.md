---
title: HTTP长连接，短连接和连接池
subtitle: 从一次压测问题说起
date: "2019-05-01"
description: ""
url: /blog/keepalive/
image: "/blog/keepalive/title.jpeg"
---
最近在复盘研究去年压测期间出现的一些网络问题时，重新对HTTP和TCP连接进行了深入学习，也对压测期间觉得"诡异"的问题有了新的理解
<!--more-->
### 问题背景
去年压测期间，在微服务架构下，系统某服务由于客户端（其他业务系统
）调用压力较大，导致连接数过多，出现异常。
* **调用方式**: HTTP长连接调用
* **部署环境**: 阿里云 + Docker
* **负载均衡**: 阿里云SLB（7层结构）
* **异常现象**: 服务端连接数过多，出现异常
* **异常处理**: 将客户端调用由长连接改为短连接后，连接数下降，压力得到缓解，异常消失

问题是得到解决了，但问题**为什么能得到解决**却让我百思不得其解。
按理说长连接能复用连接，短连接不能。但在这儿长连接却使连接数过高，短连接却解决了这个问题，颇有一种："老鼠抓了猫"的讽刺。

提出方案的同学的理由是：**在之前的实践中发现短连接确实在压测中有更好的表现**。具体原因也没给出好的解释。大家提出了各种理论，有怀疑是连接泄漏的，还有怀疑是经过的阿里云SLB带来的问题的等等。但到最后还是不了了之，终究没给出令人信服的答案。

几个月之后，我又偶然间想起了这个问题。这一次我决定从头开始，从TCP出发，弄清楚这个"悬案"

### TCP连接
众所周知，采用TCP协议进行网络通信时，在真正的读写操作之前，server与client之间必须建立一个连接，这也是我们常说的**"三次握手"**


#### TCP短连接
让我们先看看短连接的情况：
client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起close操作（一般的server不会回复完client后立即关闭连接的）。短连接一般只会在client/server间传递一次读写操作。

当读写操作完成后，双方不再需要这个连接时，它们就可以释放这个连接。而释放则又需要**四次握手**，所以说每个连接的建立和释放都是需要消耗资源和时间的。

#### TCP长连接

由于我们不希望资源都浪费在频繁建立和释放TCP连接上，这时候TCP长连接的方案便出现了。

当我们使用长连接时，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，**它们之间的连接并不会主动关闭**，后续的读写操作会继续使用这个连接。

那怎么确定等待的时候客户端还存在呢，这时候就需要说一个概念：TCP保活功能。

**保活功能主要为服务器应用提供，服务器应用希望知道客户主机是否崩溃，从而可以代表客户使用资源**。如果客户已经消失，使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，则服务器将应远等待客户端的数据，保活功能就是试图在服务器端检测到这种半开放的连接。

如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下4个状态之一：

* 客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。
* 客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。
* 客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。
* 客户机正常运行，但是服务器不可达，这种情况与2类似，TCP能发现的就是没有收到探查的响应。


但从上面可以看出，保持连接后虽然可以使用TCP保活功能探测长连接的存活状况，不过这里存在一个问题，存活功能的探测周期太长，还有就是它只是探测TCP连接的存活，遇到恶意的连接时，就会白白浪费连接资源。所以一般都默认关闭了TCP长连接



### HTTP长连接
### 连接池
### Go语言中如何进行HTTP请求
### 总结




