## Redis 五种基本数据结构
### string
Redis的字符串是动态字符串，内部结构类似于ArrayList,采用预分配冗余空间的方式来减少内存的频繁分配
### list
Redis的列表类似LinkedList, 类似链表（双向）而不是数组，意味着list的插入和删除操作非常快，时间复杂度O(1)，但是索引定位很慢，复杂度O(n)</br>

Redis的列表常用来做异步队列</br>

Itrim操作，用来截取一个区间，之外的统统砍掉。常用来实现一个定长的链表

#### 底层存储
Redis list的底层存储不是一个简单的链表，而是一个“快速链表”（quicklist）的一个结构。
首先在列表元素较少的情况下，会使用一块连续的内存存储，这个结构是ziplist，即压缩列表。它将所有的元素彼此紧挨在一起存储，分配的是一块连续的内存。当数据比较多的时候才改成quicklist。</br>
所以Redis将链表和ziplist结合起来组成quicklist，也就是将多个ziplist使用双向指针穿起来使用。

### hash
Redis的字典只能是字符串，Redis为了追求高性能，采用rehash策略，rehash同时保留新旧两个hash结构，一点一点迁移到新的hash结构。

### set
set 内部键值对是无序的，唯一的。可以用来做去重功能

### zset
类似set 和 map的结合体，一方面可以保证value唯一性，一方面可以给每个value赋予一个score</br>
内部实现用的是一个叫做“跳跃列表”的数据结构

#### 跳跃列表
因为zset要支持插入和删除，所以不适合数组。但是链表又不能二分查找。
跳跃列表最下面一层所有元素都会串起来，然后每隔几个选出一个代表，再串起来，叫二级代表。同样的策略还有三级，四级....
跳跃列表采取一个随机策略来决定新元素可以兼职到几层

## Redis 应用
### Redis分布式锁
redis 的setnx现在已经是原子操作

redis的分布式锁不要用于较长时间的任务

如果一个锁支持**同一个线程**多次加锁，这个锁就是**可重入的**（防止死锁）
### Redis延时队列
#### 阻塞读
blpop/brpop
阻塞读在队列没有数据的时候，会立即进入休眠状态，一旦数组到来，则立即醒过来，消息的延迟几乎为0
#### 延时队列实现
可以将消息序列化成一个字符串作为zset的value，这个消息的到期处理时间作为score，然后用多个线程轮询zset获取到期的任务进行处理。
zrem是抢占任务的关键，因为可能被多个进程抢占。要通过zrem决定唯一的属主。

### Redis Scan操作

## Redis 原理

### 线程IO模型
### 通信协议
### 持久化
### 管道
### 事务
### PubSub
### PubSub

