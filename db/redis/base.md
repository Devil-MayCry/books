## Redis 五种基本数据结构
### string
Redis的字符串是动态字符串，内部结构类似于ArrayList,采用预分配冗余空间的方式来减少内存的频繁分配
### list
Redis的列表类似LinkedList, 类似链表（双向）而不是数组，意味着list的插入和删除操作非常快，时间复杂度O(1)，但是索引定位很慢，复杂度O(n)</br>

Redis的列表常用来做异步队列</br>

Itrim操作，用来截取一个区间，之外的统统砍掉。常用来实现一个定长的链表

#### 底层存储
Redis list的底层存储不是一个简单的链表，而是一个“快速链表”（quicklist）的一个结构。
首先在列表元素较少的情况下，会使用一块连续的内存存储，这个结构是ziplist，即压缩列表。它将所有的元素彼此紧挨在一起存储，分配的是一块连续的内存。当数据比较多的时候才改成quicklist。</br>
所以Redis将链表和ziplist结合起来组成quicklist，也就是将多个ziplist使用双向指针穿起来使用。

### hash
Redis的字典只能是字符串，Redis为了追求高性能，采用rehash策略，rehash同时保留新旧两个hash结构，一点一点迁移到新的hash结构。

### set
set 内部键值对是无序的，唯一的。可以用来做去重功能

### zset
类似set 和 map的结合体，一方面可以保证value唯一性，一方面可以给每个value赋予一个score</br>
内部实现用的是一个叫做“跳跃列表”的数据结构

#### 跳跃列表
因为zset要支持插入和删除，所以不适合数组。但是链表又不能二分查找。
跳跃列表最下面一层所有元素都会串起来，然后每隔几个选出一个代表，再串起来，叫二级代表。同样的策略还有三级，四级....
跳跃列表采取一个随机策略来决定新元素可以兼职到几层

## Redis 应用
### Redis分布式锁
redis 的setnx现在已经是原子操作

redis的分布式锁不要用于较长时间的任务

如果一个锁支持**同一个线程**多次加锁，这个锁就是**可重入的**（防止死锁）
### Redis延时队列
#### 阻塞读
blpop/brpop
阻塞读在队列没有数据的时候，会立即进入休眠状态，一旦数组到来，则立即醒过来，消息的延迟几乎为0
#### 延时队列实现
可以将消息序列化成一个字符串作为zset的value，这个消息的到期处理时间作为score，然后用多个线程轮询zset获取到期的任务进行处理。
zrem是抢占任务的关键，因为可能被多个进程抢占。要通过zrem决定唯一的属主。

### Redis Scan操作
- scan通过游标分步进行，不会阻塞线程
- 返回的结果可能有重复
- 遍历过程中如果有数据修改，改动后的数据能不能遍历到是不确定的
- scan不是从0位到末尾，而是采用了高位进位加法来遍历，是考虑到字典的扩容和缩容时避免槽位的遍历重复和遗漏。当LoadFactor达到阀值，需要重新分配一个新2倍大小的数组。然后将所有的元素全部rehash挂到新的数组。rehash就是将元素的hash值对数组长度进行取模运算，长度变了，每个元素挂接的槽位可能也会发生变化。
- 集群环境下，如果某个key太大，会导致数据迁移卡顿。
  
## Redis 原理
### 线程IO模型
#### 非阻塞IO
非阻塞IO在套接字对象上提供了一个选项Non_Blocking，当这个选项打开时，读写方法不会阻塞，而是能读多少读多少，能写多少写多少。线程在读写IO时可以不必再阻塞了，读写可以瞬间完成。

#### 事件轮询（多路复用）
非阻塞IO的问题是不知道什么时候继续读，也不知道什么时候继续写。

时间轮询API就是解决这个问题的。还提供timeout参数，如果没有任何事件到来，最多等待timeout事件，线程处于阻塞状态。一旦期间有任何事件的到来，就可以立即返回。时间过了之后还是没有任何事件到来，也会返回。

因为我们通过select系统调用**同时处理多个通道描述符的读写事件**，因此我们将这类系统调用称为多路复用API。现在的已经不在使用select，改用epoll了。

redis会将每个客户端套接字都关联一个指令队列，排队进行顺序处理。</br>
也会关联一个响应队列。如果队列为空，意味着连接暂时处于空闲状态，不需要去获取写事件，也就是可以将当前的客户端描述符从write_fds里面移除来。等到队列有数据了，再将描述符放进去，避免select系统调用立即返回写事件，令CPU飙升。

#### 定时任务
如果线程阻塞在select系统调用上，定时任务将无法准确调度。那怎么解决呢？

redis的定时任务会被记录在“最小堆”里。每个循环周期处理，取出到点的任务处理。完成后将最快要执行的任务还需要的时间记录下来，这个时间就是select系统调用的timeout参数。

### 通信协议

RESP是redis的序列化协议，是一种直观的文本协议。实现简单，解析性能极好。

客户端向服务器发送的指令只有一种格式，多行字符串数组。

服务端回复客户端分为：
- 单行字符串响应
- 错误响应
- 整数响应
- 多行字符串响应
- 数组响应
- 嵌套

### 持久化
redis的持久化机制分为两种：

#### 快照
快照是对内存数据的二进制序列化。

因为redis是单线程，服务线上请求的同时还需要进行内存快照。内存快照需要进行文件IO，而IO不能使用多路复用。
这时，就需要使用操作系统的多进程COW（copy on write）机制来实现快照持久化

redis持久化时会调用glibc的函数fork产生一个子进程，快照持久化完全交给子进程处理，父进程继续处理客户端请求。子进程刚产生时，它和父进程共享内存里面的代码段和数据段。

子进程做持久化，不会修改现有的内存数据结构，只是对数据结构进行遍历读取，然后序列化写到磁盘中。父进程继续响应请求，然后对内存数据进行修改。

这个时候就会使用操作系统的COW机制进行数据段页面的分离。当父进程对其中一个页面的数据进行修改时，会将被共享的页面复制一份份分离出来，然后对这个**复制**的页面就行修改。这时子进程相应的页面是没有变化的，还是进程产生时那一瞬间的数据

#### AOF日志
是内存数据修改指令记录文本。redis是先执行指令再进行日志存盘

在长期运行中，AOF日志会越来越大，需要进行重写。原理是开辟一个子进程对内存进行遍历，转换成一系列Redis的操作指令，序列化到一个新的AOF日志文件中。完成后再将操作期间发生的增量AOF日志追加到这个新的AOF日志文件中，完毕后替代旧的AOF日志文件。

redis调用Linux 提供的fsync函数，定时将操作同步到AOF日志中。

因为同步比较耗资源，通常Redis主节点不会进行持久化操作。所以要注意网络分区的问题。

#### Redis 4.0混合持久化
因为rdb恢复内存会丢数据，但AOF又比较慢，所以提供混合持久化

将rdb文件内容和增量AOF日志文件存在一起。先加载rdb，再重放增量AOF日志。

### 管道
管道不是服务端提供的功能，而是客户端提供的

write操作只负责将数据写到本地操作系统内核的发送缓冲中然后返回。如果缓冲满了，那么就需要等待空出空闲空间来，这就是写操作IO的真正耗时。同样，读操作也是一样的。

对于管道来说，连续的write根本没有耗时，之后第一个read操作会等待一个网络的来回开销，然后所有的响应消息就都已经送回到内核的读缓冲了，然后就能直接read从缓冲拿到结果，瞬间返回。
### 事务
### PubSub
### PubSub

## 对象压缩
