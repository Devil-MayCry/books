## Redis 五种基本数据结构
### string
Redis的字符串是动态字符串，内部结构类似于ArrayList,采用预分配冗余空间的方式来减少内存的频繁分配
### list
Redis的列表类似LinkedList, 类似链表（双向）而不是数组，意味着list的插入和删除操作非常快，时间复杂度O(1)，但是索引定位很慢，复杂度O(n)</br>

Redis的列表常用来做异步队列</br>

Itrim操作，用来截取一个区间，之外的统统砍掉。常用来实现一个定长的链表

#### 底层存储
Redis list的底层存储不是一个简单的链表，而是一个“快速链表”（quicklist）的一个结构。
首先在列表元素较少的情况下，会使用一块连续的内存存储，这个结构是ziplist，即压缩列表。它将所有的元素彼此紧挨在一起存储，分配的是一块连续的内存。当数据比较多的时候才改成quicklist。</br>
所以Redis将链表和ziplist结合起来组成quicklist，也就是将多个ziplist使用双向指针穿起来使用。

### hash
Redis的字典只能是字符串，Redis为了追求高性能，采用rehash策略，rehash同时保留新旧两个hash结构，一点一点迁移到新的hash结构。

### set
set 内部键值对是无序的，唯一的。可以用来做去重功能

### zset
类似set 和 map的结合体，一方面可以保证value唯一性，一方面可以给每个value赋予一个score</br>
内部实现用的是一个叫做“跳跃列表”的数据结构

#### 跳跃列表
因为zset要支持插入和删除，所以不适合数组。但是链表又不能二分查找。
跳跃列表最下面一层所有元素都会串起来，然后每隔几个选出一个代表，再串起来，叫二级代表。同样的策略还有三级，四级....
跳跃列表采取一个随机策略来决定新元素可以兼职到几层

## Redis 应用
### Redis分布式锁
redis 的setnx现在已经是原子操作

redis的分布式锁不要用于较长时间的任务

如果一个锁支持**同一个线程**多次加锁，这个锁就是**可重入的**（防止死锁）
### Redis延时队列
#### 阻塞读
blpop/brpop
阻塞读在队列没有数据的时候，会立即进入休眠状态，一旦数组到来，则立即醒过来，消息的延迟几乎为0
#### 延时队列实现
可以将消息序列化成一个字符串作为zset的value，这个消息的到期处理时间作为score，然后用多个线程轮询zset获取到期的任务进行处理。
zrem是抢占任务的关键，因为可能被多个进程抢占。要通过zrem决定唯一的属主。

### Redis Scan操作
- scan通过游标分步进行，不会阻塞线程
- 返回的结果可能有重复
- 遍历过程中如果有数据修改，改动后的数据能不能遍历到是不确定的
- scan不是从0位到末尾，而是采用了高位进位加法来遍历，是考虑到字典的扩容和缩容时避免槽位的遍历重复和遗漏。当LoadFactor达到阀值，需要重新分配一个新2倍大小的数组。然后将所有的元素全部rehash挂到新的数组。rehash就是将元素的hash值对数组长度进行取模运算，长度变了，每个元素挂接的槽位可能也会发生变化。
- 集群环境下，如果某个key太大，会导致数据迁移卡顿。
  
## Redis 原理
### 线程IO模型
#### 非阻塞IO
非阻塞IO在套接字对象上提供了一个选项Non_Blocking，当这个选项打开时，读写方法不会阻塞，而是能读多少读多少，能写多少写多少。线程在读写IO时可以不必再阻塞了，读写可以瞬间完成。

#### 事件轮询（多路复用）
非阻塞IO的问题是不知道什么时候继续读，也不知道什么时候继续写。

时间轮询API就是解决这个问题的。还提供timeout参数，如果没有任何事件到来，最多等待timeout事件，线程处于阻塞状态。一旦期间有任何事件的到来，就可以立即返回。时间过了之后还是没有任何事件到来，也会返回。

因为我们通过select系统调用**同时处理多个通道描述符的读写事件**，因此我们将这类系统调用称为多路复用API。现在的已经不在使用select，改用epoll了。

redis会将每个客户端套接字都关联一个指令队列，排队进行顺序处理。</br>
也会关联一个响应队列。如果队列为空，意味着连接暂时处于空闲状态，不需要去获取写事件，也就是可以将当前的客户端描述符从write_fds里面移除来。等到队列有数据了，再将描述符放进去，避免select系统调用立即返回写事件，令CPU飙升。

#### 定时任务
如果线程阻塞在select系统调用上，定时任务将无法准确调度。那怎么解决呢？

redis的定时任务会被记录在“最小堆”里。每个循环周期处理，取出到点的任务处理。完成后将最快要执行的任务还需要的时间记录下来，这个时间就是select系统调用的timeout参数。

### 通信协议
### 持久化
### 管道
### 事务
### PubSub
### PubSub

