### 索引

#### 聚集索引 和非聚集索引
* 就是以主键创建的索引
* 非聚集索引就是以非主键创建的索引
* 聚集索引在叶子节点存储的是表中的数据
* 非聚集索引在叶子节点存储的是主键和索引列

#### 使用方法
* 使用非聚集索引查询出数据时，拿到叶子上的主键再去查到想要查找的数据。\(拿到主键再查找这个过程叫做回表\)
* 在创建多列索引中也涉及到了一种特殊的索引-- 覆盖索引
* 如果不是聚集索引，叶子节点存储的是主键+列值，最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢
* 覆盖索引就是把要查询出的列和索引是对应的，不做回表操作

#### 最佳实践
* 最左前缀匹配原则。这是非常重要、非常重要、非常重要（重要的事情说三遍）的原则，MySQL会一直向右匹配直到遇到范围查询（&gt;,&lt;,BETWEEN,LIKE）就停止匹配。
* 尽量选择区分度高的列作为索引，区分度的公式是 COUNT\(DISTINCT col\) / COUNT\(\*\)。表示字段不重复的比率，比率越大我们扫描的记录数就越少。
* 索引列不能参与计算，尽量保持列“干净”。比如，FROM\_UNIXTIME\(create\_time\) = '2016-06-06' 就不能使用索引，原因很简单，B+树中存储的都是数据表中的字段值，但是进行检索时，需要把所有元素都应用函数才能比较，显然这样的代价太大。所以语句要写成 ： create\_time = UNIX\_TIMESTAMP\('2016-06-06'\)
* 尽可能的扩展索引，不要新建立索引。比如表中已经有了a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。
* 单个多列组合索引和多个单列索引的检索查询效果不同，因为在执行SQL时，MySQL只能使用一个索引，会从多个单列索引中选择一个限制最为严格的索引。

### 锁

* 对于UPDATE、DELETE、INSERT语句，InnoDB会自动给涉及数据集加排他锁（X\)
* MyISAM在执行查询语句SELECT前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预
* 乐观锁是一种思想，具体实现是，表中有一个版本字段，第一次读的时候，获取到这个字段。处理完业务逻辑开始更新的时候，需要再次查看该字段的值是否和第一次的一样。如果一样更新，反之拒绝。之所以叫乐观，因为这个模式没有从数据库加锁，等到更新的时候再判断是否可以更新。
* 悲观锁是数据库层面加锁，都会阻塞去等待锁。



